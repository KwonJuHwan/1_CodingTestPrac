# 1_CodingTestPrac
DoIt

위상정렬

53: 
공간 최적화: 처음부터 0인거와, 위상정렬로 인해, 0이된 것을 분리해서 visit을 없앰
아이디어 : 정렬의 순서는 관계가 없으므로, queue를 굳이 동적으로 append 할 필요 없음

54: 그래프탐색에 있어 내가 반드시 봐야할 메커니즘 노드 경로를 선택할때, 하나를 선택하게 함으로써, 노드 weight의 덧셈 중복 방지
#둘 중에 하나를 선택함으로써, 노드 weight의 중복 덧셈 방지 (길이 여러가지 이므로)
        # answer[4]= 1->4 // answer[3]+weight[3] = 1->3->4 둘중에 높은 값으로 선택
        answer[i] = max(answer[i],answer[now]+weight[now])
55: 리버스 그래프를 도입하는 부분. 아이디어를 전혀 얻지 못하고, 문제풀이 해석에만 집중하였기 때문에, 반드시 복습 필요.
#임계경로 구하기
#1분도 쉬지 않고, 달린다 -> 최대거리에 해당하는 엣지들 
#엣지에 weight가 존재-> 저장할때, (도착노드, weight)를 저장하기
#리버스 계산시 visit을 사용해야하는 이유는?
#엣지는 한 노드안에 여러개의 노드가 꼽혀있을 수 있다. 그렇기 때문에, queue에서 노드를 pop한 상황일때, 모든 엣지에 대해 최대거리인 엣지들을
#탐색해야 하므로, visit 여부에 관계없이 항상 실행되어야 한다. 하지만 node를 꺼내었을때, visit연산을 집어넣지 않는다면
#엣지탐색을 진행하였을때, queue에 이전에 넣었던 노드가 다시 들어가, 탐색했던 노드에 꼽혀있는 엣지들을 다시 탐색하여 resultCount를 중복하여
#셀 수 있는 오류가 발생한다. 따라서 node는 queue에 한번씩만 들어가야 하므로, visit연산을 넣어야한다.
#리버스가 아닌 첫번째 위상정렬은 진입차수가 0일때만, queue에 노드를 넣으므로, 중복탐색이 불가능하다.
#리버스를 이용하는 이유?
#리버스를 사용하는 이유는 리버스를 사용을 해야, 탐색중인 거리의 최댓값과 비교를 할 수 있기때문
#만약 리버스를 사용하지않고, 그래프 탐색을 진행한다면, 이전 엣지 weight+ 이전 노드의 누적 weight와 현재의 노드 weight를 비교해야하기 때문에
#queue를 이용하는 차원에서 할 수 없는 알고리즘이다. 이미 노드의 weight들과 엣지의 weight를 아는 상황이므로,
#다음 엣지 weight+ 다음 노드 weight= 현재 노드 weight 계산을 진행하는 것이 옮음
